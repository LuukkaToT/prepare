# RabbitMQ 常见面试题整理

## 一、基础概念

### 1. 什么是RabbitMQ？
RabbitMQ是一个开源的消息队列系统，基于AMQP（高级消息队列协议）标准。主要特点：
- 使用Erlang编写
- 提供可靠的消息传递
- 确保消息的可靠性和顺序性
- 提供灵活的路由和消息确认机制
- 实现服务间的高度解耦

### 2. RabbitMQ支持哪些协议？
- **主要协议**：AMQP
- **其他支持**：MQTT、STOMP等

### 3. RabbitMQ基本概念
- **Broker**：消息队列服务器实体
- **Exchange**：消息交换机，指定消息按什么规则路由到哪个队列
- **Queue**：消息队列载体，存储消息等待消费者消费
- **Binding**：绑定，把exchange和queue按照路由规则绑定起来
- **Routing Key**：路由关键字，exchange根据这个关键字进行消息投递
- **VHost**：虚拟broker，拥有独立的权限系统，可作为不同权限隔离的手段
- **Producer**：消息生产者，投递消息的程序
- **Consumer**：消息消费者，接受消息的程序
- **Channel**：消息通道，在客户端的每个连接里可建立多个channel

> 注：由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一线路。

## 二、消息队列的作用

### 4. 解耦、异步、削峰是什么？

**解耦**：
- 问题：A系统需要向BCD三个系统发送数据，通过接口调用发送，系统间严重耦合
- 解决：使用MQ后，A系统产生数据发送到MQ，需要数据的系统自己去消费
- 优势：新系统需要数据直接从MQ消费；某系统不需要数据取消消费即可

**异步**：
- 问题：A系统处理一个请求需要本地写库3ms + BCD三系统写库950ms = 953ms
- 解决：使用MQ后，A系统发送3条消息到MQ耗时5ms，总时长3+5=8ms
- 优势：大幅提升响应速度

**削峰**：
- 作用：减少高峰时期对服务器的压力

### 5. 消息队列有什么缺点？

**系统可用性降低**：
- 消息队列挂了，整个系统受影响

**系统复杂度提高**：
- 需要考虑一致性问题
- 如何保证消息不被重复消费
- 如何保证消息可靠性传输

**一致性问题**：
- A系统处理完直接返回成功，但BCD系统中某个系统处理失败，数据不一致

## 三、不同MQ产品对比

### 6. Kafka、ActiveMQ、RabbitMQ、RocketMQ对比

| 特性 | ActiveMQ | RabbitMQ | RocketMQ | Kafka |
|------|----------|----------|----------|-------|
| 单机吞吐量 | 万级 | 万级 | 10万级 | 10万级 |
| topic数量影响 | - | - | 几百/几千级别，影响较小 | 几十到几百时吞吐量大幅下降 |
| 时效性 | ms级 | 微秒级（最低） | ms级 | ms级 |
| 可用性 | 高（主从架构） | 高（主从架构） | 非常高（分布式） | 非常高（分布式） |
| 消息可靠性 | 较低概率丢失 | 基本不丢 | 可做到0丢失 | 可做到0丢失 |
| 功能支持 | 功能完备 | 并发能力强，性能好 | 功能完善，扩展性好 | 功能简单，适合大数据场景 |

**选择建议**：
- **中小型公司**：推荐RabbitMQ（技术实力一般，有活跃开源社区）
- **大型公司**：推荐RocketMQ（基础架构研发实力强）
- **大数据场景**：推荐Kafka（实时计算、日志采集的业内标准）

## 四、RabbitMQ工作模式

### 7. Simple模式（简单收发模式）
- 消息生产者将消息放入队列
- 消息消费者监听队列，有消息就消费
- 消息被消费后自动从队列删除
- **隐患**：消息可能没被正确处理就已从队列消失

### 8. Work工作模式（资源竞争）
- 多个消费者监听同一个队列
- 消费者竞争消费消息
- **隐患**：高并发下可能一个消息被多个消费者使用，需要设置同步开关

### 9. Publish/Subscribe发布订阅模式（共享资源）
- 每个消费者监听自己的队列
- 生产者发消息给broker
- 交换机将消息转发到绑定的每个队列
- 每个队列都会接收到消息

### 10. Routing路由模式
- 消息生产者发送消息给交换机
- 交换机根据路由key匹配对应的消息队列
- 只有匹配的消费者才能消费消息
- **应用场景**：错误通知、异常处理等

### 11. Topic主题模式（路由模式的一种）
- 支持模糊匹配路由key
- **星号（*）**：匹配任意一个单词
  - 例：`log.*` 匹配 `log.error`、`log.info`，但不匹配 `log.error.debug`
- **井号（#）**：匹配零个或多个单词
  - 例：`log.#` 匹配 `log`、`log.error`、`log.error.debug`

## 五、消息可靠性保证

### 12. 如何保证消息的顺序性？
**解决方案**：
- 拆分多个queue，每个queue对应一个consumer
- 或者使用一个queue对应一个consumer，consumer内部用内存队列排队

### 13. 如何保证消息不被重复消费（幂等性）？
**重复消费原因**：
- 消费者消费完消息后发送确认信息
- 网络故障导致确认信息未传达
- 消息队列重新分发消息

**解决方案**：
- 保证消息的唯一性标识
- 消费时根据唯一标识判断是否已消费
- 使用日志表记录已处理消息的ID

### 14. 如何确保消息正确发送至RabbitMQ？

**发送方确认模式**：
- 设置信道为confirm模式
- 所有消息被指派唯一ID
- 消息投递成功后发送确认（包含唯一ID）
- 发生错误时发送nack消息

### 15. 如何确保消息接收方消费了消息？

**接收方确认机制**：
- 消费者接收消息后必须确认
- 只有确认后RabbitMQ才删除消息
- 连接断开时RabbitMQ重新分发消息

### 16. 如何保证RabbitMQ消息的可靠传输？

**生产者丢失消息**：
- 使用transaction机制（吞吐量低）
- 使用confirm模式（推荐）

**消息队列丢失消息**：
- 开启消息持久化
- 设置queue的durable为true
- 发送消息时设置deliveryMode=2

**消费者丢失消息**：
- 改为手动确认消息模式
- 处理消息成功后再手动确认

## 六、高级特性

### 17. 消息的分发和路由

**消息分发**：
- 采用循环（round-robin）方式
- 每条消息只分发给一个消费者
- 通过路由可实现多消费功能

**消息路由**：
- **fanout**：广播到所有绑定队列
- **direct**：路由键完全匹配
- **topic**：支持通配符匹配

### 18. 消息传输基础
- 基于TCP连接的信道（Channel）传输
- 信道是TCP连接内的虚拟连接
- 避免TCP连接创建销毁的性能开销

### 19. 为什么不对所有消息都使用持久化？
**缺点**：
- 性能下降（写磁盘比写RAM慢10倍）
- 集群方案中可能出现问题

**建议**：
- 仅对关键消息持久化
- 综合考虑性能需求和业务重要性
- 单服务器10万条/秒以上需要SSD支持

## 七、集群和高可用

### 20. RabbitMQ集群如何保证高可用？

**普通集群模式**：
- 多台机器启动多个RabbitMQ实例
- queue只在一个实例上，其他实例同步元数据
- 提高吞吐量，但不保证高可用

**镜像集群模式**（高可用模式）：
- queue的元数据和消息都存在多个实例上
- 每个节点都有完整的queue镜像
- 任一机器宕机，其他节点仍可提供服务
- 缺点：性能开销大，网络带宽消耗重

## 八、高级应用场景

### 21. 如何处理高并发场景下的性能问题？
- 使用集群功能实现负载均衡
- 调整消息持久化设置
- 优化交换机和队列匹配规则

### 22. 如何实现消息优先级处理？
- 设置消息的优先级字段
- 使用优先级队列插件
- 优先级高的消息优先被消费

### 23. 如何实现延迟队列？
- 使用`rabbitmq_delayed_message_exchange`插件
- 提供延迟交换器（Delayed Message Exchange）
- 消息等待指定延迟时间后处理

### 24. 如何实现死信队列？
- 使用`rabbitmq_dead_letter_exchange`插件
- 提供死信交换机（Dead Letter Exchange）
- 无法处理的消息路由到死信队列

### 25. RabbitMQ的使用场景
- 服务间异步通信
- 顺序消费
- 定时任务
- 请求削峰

---

## 总结

RabbitMQ作为一个成熟的消息队列中间件，在微服务架构中扮演着重要角色。掌握其基本概念、工作模式、可靠性保证机制以及高级特性，对于后端开发人员来说是必不可少的技能。在实际应用中，需要根据具体的业务场景选择合适的工作模式和配置策略。
